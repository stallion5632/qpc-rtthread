# 实现原理

## qf_opt_layer

`qf_opt_layer.c` 实现了RT-Thread下QP/C的事件分级调度与优化层，核心原理如下：

### 1. 分级事件暂存缓冲（Staging Buffers）
- 事件根据优先级（高/普通/低）进入不同的环形暂存缓冲区（l_stagingBuffers）。
- 每个缓冲区为定长队列，溢出时有独立统计。

### 2. 调度线程与信号量
- 独立调度线程 dispatcherThread，优先级可配置。
- 线程通过信号量唤醒，批量处理各优先级缓冲区的事件。
- 空闲钩子（idle hook）自动检测缓冲区有事件时唤醒调度线程。

### 3. 策略接口（Strategy Pattern）
- 通过 QF_DispatcherStrategy 结构体，支持自定义事件合并、优先级比较、丢弃、分级等策略。
- 可动态切换策略（如默认策略、高性能策略）。

### 4. 批量处理与合并/丢弃/重试
- 调度线程每次批量取出同优先级事件，遍历处理：
  - 支持事件合并（如信号相同可合并，减少冗余）。
  - 支持事件丢弃（如队列过满、非关键事件可丢弃）。
  - 支持事件重试（如关键事件投递失败可降级重试）。
- 事件最终通过RT-Thread邮箱投递到目标AO。

### 5. 运行时统计与调优
- 实时统计调度周期、处理事件数、合并/丢弃/重试数、最大/平均批量、队列溢出等。
- 支持接口获取和重置统计数据，便于性能分析和调优。

### 6. 典型流程
1. AO或ISR通过QF_postFromISR等接口投递事件，事件进入分级缓冲。
2. 调度线程被唤醒，批量处理各级缓冲区事件。
3. 按策略合并/丢弃/重试，最终投递到目标AO邮箱。
4. 应用可通过接口/命令获取运行时统计，辅助调优。


## qf_isr_relay

`qf_isr_relay.c` 实现了RT-Thread下QP/C的ISR安全事件发布机制，核心原理如下：

### 1. 结构体设计

- 使用 `QF_ISRRelay` 结构体集中管理所有中继相关资源，包括：
  - 主环形缓冲区（main_rb）和溢出环形缓冲区（overflow_rb）
  - 缓冲区存储空间
  - 统计信息（QF_ISRStats）与互斥保护
  - 中继线程句柄、信号量
  - 状态标志（如overflow_active、initialized等）

### 2. 事件缓冲与中继线程

- **主缓冲区**：ISR优先写入，正常情况下事件都存于此。
- **溢出缓冲区**：主缓冲区满时，事件写入溢出区，防止高峰丢失。
- **中继线程**：高优先级线程，等待信号量唤醒，批量取出缓冲区事件并通过QF_PUBLISH发布到QP/C框架。
  - 先处理溢出区，再处理主缓冲区，保证高峰事件优先。
  - 批量大小自适应，根据上次处理耗时动态调整。

### 3. 关键流程

#### ISR安全事件发布（QF_publishFromISR）
1. 进入临界区，构造事件描述体。
2. 优先尝试写入主缓冲区，若满则写入溢出缓冲区。
3. 若两者都满则丢弃并统计丢失。
4. 写入成功后释放信号量，唤醒中继线程。
5. 离开临界区。

#### 中继线程处理（QF_isrRelayThreadEntry）
1. 等待信号量唤醒。
2. 先批量处理溢出缓冲区，再处理主缓冲区。
3. 每次处理后更新统计信息（处理数、丢失数、最大批量、最大耗时等）。
4. 根据处理耗时自适应调整批量大小。

### 4. 统计与调试

- 所有事件处理、丢失、批量、耗时等均有详细统计，支持shell命令打印。
- 通过日志可追踪每次ISR事件发布和AO事件流转。

### 5. 线程与缓冲区参数

- 所有线程优先级、栈、缓冲区大小均可通过头文件宏配置。
- 典型配置：主缓冲区64，溢出区16，中继线程优先级高于普通任务。

### 6. 典型调用关系

1. QF_init()/QF_run()自动初始化中继系统。
2. AO或ISR通过QF_PUBLISH_FROM_ISR发布事件。
3. 事件进入缓冲区，唤醒中继线程。
4. 中继线程批量发布事件到QP/C。
5. 应用可通过shell命令查看统计和调试。
